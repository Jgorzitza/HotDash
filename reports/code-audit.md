# HotDash Code Audit

## Security Risks
- The Chatwoot client trusts the `baseUrl` provided via environment variables and interpolates it directly into fetch targets without any allow-listing or hostname validation, so a compromised config could redirect the server to attacker-controlled hosts (SSRF) or clear-text endpoints. Add strict validation (e.g., URL parser + known host list) and enforce HTTPS before issuing requests that forward the API token.【F:packages/integrations/chatwoot.ts†L2-L55】
- Runtime logging forwards the Supabase service key in a bearer header to an edge function on every call, yet falls back to `console.log` when the endpoint fails. That fallback can leak structured metadata (potentially with PII) to stdout while still leaving the high-privilege service key resident in memory. Consider swapping to short-lived access tokens, redacting sensitive metadata on fallback, and gating logger initialization when the service key is absent.【F:app/utils/logger.server.ts†L21-L140】
- The session-token claims endpoint only authenticates the request and decodes the presented JWT; it never verifies that the decoded destination matches the authenticated shop or that the token is still inside its `nbf`/`exp` window beyond trusting the library. Add invariant checks (dest, aud, session id) against the authenticated session before returning the decoded payload to reduce confused-deputy style misuse.【F:app/routes/api.session-token.claims.ts†L33-L68】
- Webhook handlers accept any HTTP verb Remix routes to `action` and log shop identifiers in plaintext before updating state. Explicitly restrict to `POST`, redact logs where possible, and guard database writes with defensive parsing (e.g., validate `payload.current` is an array) to avoid malformed data from partially authenticated webhook deliveries.【F:app/routes/webhooks.app.scopes_update.tsx†L5-L20】【F:app/routes/webhooks.app.uninstalled.tsx†L5-L16】

## Code Quality Observations
- `recordDashboardSessionOpen` swallows persistence errors and only prints them to the console, which hides telemetry failures during incidents. Surface the error through structured logging or metrics so operators can spot fact-write regressions quickly.【F:app/services/dashboardSession.server.ts†L10-L31】
- The cache module exposes a global `Map` without namespace scoping or instrumentation; callers cannot observe eviction timing or cache hits. Wrapping the map in a small helper with logging or metrics hooks would simplify tuning and help during load testing.【F:app/services/cache.server.ts†L1-L30】
- Complex tiles in the dashboard loader all follow the same success/error pattern. Extracting reusable helpers for error normalization (instead of inlining bespoke `ServiceError` checks per tile) would reduce boilerplate and ensure future tiles report consistent status payloads.【F:app/routes/app._index.tsx†L81-L137】

## Duplication & Maintainability
- Both Shopify services (`orders` and `inventory`) manually read GraphQL responses, set cache entries, and record facts. Consolidate shared behaviors (cache key construction, fact writes, error handling) into utilities to avoid diverging retry/backoff semantics between the services.【F:app/services/shopify/orders.ts†L106-L210】【F:app/services/shopify/inventory.ts†L107-L182】
- Chatwoot escalation processing sorts the same message array twice (descending for `lastMessage`, ascending for the trimmed transcript). Refactoring to derive both outputs from a single sorted copy will simplify maintenance and reduce the chance of future drift when message schemas change.【F:app/services/chatwoot/escalations.ts†L207-L258】

## Endpoint Validation & Error Handling
- Dashboard loaders rely on downstream services to throw `ServiceError` with rich metadata, but the helper simply returns a generic message string. Bubble up HTTP status codes or remediation hints so the UI can differentiate between auth issues, rate limits, and configuration gaps.【F:app/routes/app._index.tsx†L81-L136】
- The Shopify webhook scope update path trusts `payload.current` to already be an array of scopes and serializes it with `.toString()`, which silently joins on commas. Validate the payload shape and persist structured scope metadata (e.g., via JSON) to prevent data loss if Shopify adds nested fields.【F:app/routes/webhooks.app.scopes_update.tsx†L5-L20】

## Performance Considerations
- Chatwoot ingestion performs sequential HTTP requests per conversation and re-sorts message arrays multiple times, which will scale poorly for busy inboxes. Batch `listMessages` calls with `Promise.all`, add request timeouts, and avoid redundant array copies to keep collection latency low.【F:app/services/chatwoot/escalations.ts†L189-L258】【F:packages/integrations/chatwoot.ts†L14-L55】
- Shopify aggregation caps queries at `MAX_ORDERS` but ignores pagination cursors, so high-volume shops will silently drop data. Capture `pageInfo.hasNextPage` and iterate or schedule background jobs to process remaining orders.【F:packages/integrations/shopify.ts†L1-L18】【F:app/services/shopify/orders.ts†L106-L210】
- The in-memory cache is process-local; horizontally scaled instances will each miss and re-fetch, which risks rate limits. Consider a shared cache (Redis) or at least guard critical fetches with request coalescing to reduce duplicate upstream load.【F:app/services/cache.server.ts†L1-L30】【F:app/routes/app._index.tsx†L53-L78】

## QA & Test Coverage
- Several GA integration contract suites remain skipped with TODOs for real MCP endpoints, leaving external analytics ingest unverified in CI. Prioritize enabling these tests once credentials land to keep regression coverage intact.【F:tests/unit/contracts/ga.sessions.contract.test.ts†L142-L165】【F:tests/unit/contracts/ga_mcp.spec.ts†L1-L6】
- No automated coverage exercises the Chatwoot escalation flow or Shopify fact writers, so critical integrations rely solely on manual QA. Add integration tests with mocked HTTP responses to validate caching, fact logging, and tile shaping logic end-to-end.【F:app/services/chatwoot/escalations.ts†L274-L345】【F:app/services/shopify/orders.ts†L106-L267】
- Observability defaults such as the Supabase logger currently lack tests to ensure fallbacks do not leak sensitive metadata; capturing these behaviors in unit tests would make future refactors safer.【F:app/utils/logger.server.ts†L31-L140】
