import { serve } from "https://deno.land/std@0.208.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2.48.0";
import { createHmac } from "https://deno.land/std@0.208.0/node/crypto.ts";

const corsHeaders = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Headers": "authorization, x-client-info, apikey, content-type, x-chatwoot-signature",
};

interface ChatwootWebhookPayload {
  event: string;
  account: {
    id: number;
    name: string;
  };
  inbox?: {
    id: number;
    name: string;
  };
  conversation: {
    id: number;
    inbox_id: number;
    status: string;
    created_at: number;
    meta?: any;
    contact?: {
      name?: string;
      email?: string;
      phone?: string;
    };
    messages?: Array<{
      id: number;
      content: string;
      message_type: number;
      created_at: number;
      sender: {
        type: string;
      };
    }>;
  };
  message?: {
    id: number;
    content: string;
    message_type: number;
    created_at: number;
    sender: {
      type: string;
    };
  };
}

function verifyWebhookSignature(
  payload: string,
  signature: string | null,
  secret: string
): boolean {
  if (!signature) return false;

  const hmac = createHmac("sha256", secret);
  hmac.update(payload);
  const expectedSignature = hmac.digest("hex");

  return signature === expectedSignature;
}

async function logToObservability(
  supabase: any,
  level: string,
  message: string,
  metadata: any
) {
  await supabase.from("observability_logs").insert({
    level,
    message,
    metadata,
  });
}

function formatDraftNote(draft: any, customerMessage: string): string {
  const confidenceEmoji = draft.confidence_score >= 80 ? "‚úÖ" : draft.confidence_score >= 60 ? "‚ö†Ô∏è" : "üö®";
  const urgencyEmoji = draft.sentiment?.urgency === "urgent" ? "üö®" : 
                       draft.sentiment?.urgency === "high" ? "‚ö°" : "üìù";
  
  let note = `ü§ñ **AGENT SDK DRAFT** ${confidenceEmoji} (Confidence: ${draft.confidence_score}%)\n\n`;
  note += `${draft.draft_response}\n\n`;
  note += `---\n\n`;
  
  if (draft.sources && draft.sources.length > 0) {
    note += `üìö **Knowledge Sources:**\n`;
    draft.sources.forEach((source: any) => {
      const relevance = source.relevance ? Math.round(source.relevance * 100) : 0;
      note += `- ${source.title || source.name} (${source.version || 'latest'}) - Relevance: ${relevance}%\n`;
    });
    note += `\n`;
  }
  
  if (draft.suggested_tags && draft.suggested_tags.length > 0) {
    note += `üè∑Ô∏è **Suggested Tags:** ${draft.suggested_tags.join(', ')}\n\n`;
  }
  
  if (draft.sentiment) {
    note += `üòä **Sentiment:** ${draft.sentiment.customer_sentiment || 'neutral'}, Urgency: ${draft.sentiment.urgency || 'medium'}\n\n`;
  }
  
  note += `üéØ **Recommended Action:** ${(draft.recommended_action || 'review').toUpperCase()}\n\n`;
  
  if (draft.confidence_score < 70) {
    note += `‚ö†Ô∏è **LOW CONFIDENCE** - Review carefully or escalate\n`;
  }
  
  if (draft.sentiment?.urgency === "high" || draft.sentiment?.urgency === "urgent") {
    note += `${urgencyEmoji} **URGENT** - Customer requires immediate attention\n`;
  }
  
  note += `\n---\n`;
  note += `*Generated by Agent SDK at ${new Date().toISOString()}*\n`;
  
  return note;
}

serve(async (req: Request) => {
  // Handle CORS preflight
  if (req.method === "OPTIONS") {
    return new Response("ok", { headers: corsHeaders });
  }

  const startTime = Date.now();

  try {
    // Get environment variables
    const webhookSecret = Deno.env.get("CHATWOOT_WEBHOOK_SECRET");
    const supabaseUrl = Deno.env.get("SUPABASE_URL");
    const serviceRoleKey = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY");

    if (!webhookSecret || !supabaseUrl || !serviceRoleKey) {
      return new Response(
        JSON.stringify({ error: "Missing required environment variables" }),
        {
          status: 500,
          headers: { ...corsHeaders, "Content-Type": "application/json" },
        }
      );
    }

    // Initialize Supabase client
    const supabase = createClient(supabaseUrl, serviceRoleKey, {
      auth: { persistSession: false },
    });

    // Read and verify webhook signature
    const rawBody = await req.text();
    const signature = req.headers.get("X-Chatwoot-Signature");

    if (!verifyWebhookSignature(rawBody, signature, webhookSecret)) {
      await logToObservability(supabase, "WARN", "Invalid webhook signature", {
        signature,
        ip: req.headers.get("x-forwarded-for"),
      });

      return new Response(
        JSON.stringify({ error: "Invalid webhook signature" }),
        {
          status: 401,
          headers: { ...corsHeaders, "Content-Type": "application/json" },
        }
      );
    }

    // Parse webhook payload
    const payload: ChatwootWebhookPayload = JSON.parse(rawBody);

    await logToObservability(
      supabase,
      "INFO",
      "Chatwoot webhook received",
      {
        event: payload.event,
        conversation_id: payload.conversation?.id,
        message_id: payload.message?.id,
      }
    );

    // Filter: Only process customer messages
    if (
      payload.event !== "message_created" ||
      !payload.message ||
      payload.message.sender.type !== "contact" ||
      payload.conversation.status !== "open"
    ) {
      await logToObservability(
        supabase,
        "INFO",
        "Webhook event filtered out",
        {
          event: payload.event,
          sender_type: payload.message?.sender?.type,
          conversation_status: payload.conversation?.status,
          reason: "Not a customer message in open conversation",
        }
      );

      return new Response(JSON.stringify({ ok: true, filtered: true }), {
        headers: { ...corsHeaders, "Content-Type": "application/json" },
      });
    }

    // Extract conversation details
    const {
      conversation,
      message,
    } = payload;

    // Get service URLs
    const llamaIndexUrl = Deno.env.get("LLAMAINDEX_SERVICE_URL") || "http://localhost:8005";
    const agentSdkUrl = Deno.env.get("AGENTSDK_SERVICE_URL") || "http://localhost:8006";
    const chatwootToken = Deno.env.get("CHATWOOT_API_TOKEN");
    const chatwootBaseUrl = Deno.env.get("CHATWOOT_BASE_URL") || "https://hotdash-chatwoot.fly.dev";

    try {
      // Step 1: Query LlamaIndex for knowledge context
      let knowledgeResults = { results: [], sources: [] };
      try {
        const knowledgeResponse = await fetch(`${llamaIndexUrl}/api/llamaindex/query`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            query: message.content,
            top_k: 5,
            min_relevance: 0.7,
          }),
          signal: AbortSignal.timeout(5000), // 5 second timeout
        });

        if (knowledgeResponse.ok) {
          knowledgeResults = await knowledgeResponse.json();
          await logToObservability(supabase, "INFO", "LlamaIndex query successful", {
            conversation_id: conversation.id,
            results_count: knowledgeResults.results?.length || 0,
          });
        } else {
          await logToObservability(supabase, "WARN", "LlamaIndex query failed", {
            conversation_id: conversation.id,
            status: knowledgeResponse.status,
          });
        }
      } catch (error) {
        await logToObservability(supabase, "WARN", "LlamaIndex service unavailable", {
          conversation_id: conversation.id,
          error: error.message,
        });
      }

      // Step 2: Generate draft response via Agent SDK
      let draft = {
        draft_response: "I'm reviewing your message and will respond shortly.",
        confidence_score: 50,
        sources: knowledgeResults.sources || [],
        suggested_tags: [],
        sentiment: { customer_sentiment: "neutral", urgency: "medium" },
        recommended_action: "review",
      };

      try {
        const draftResponse = await fetch(`${agentSdkUrl}/api/agentsdk/draft`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            customer_message: message.content,
            customer_context: {
              name: conversation.contact?.name,
              email: conversation.contact?.email,
              conversation_id: conversation.id,
            },
            knowledge_context: knowledgeResults.results,
          }),
          signal: AbortSignal.timeout(10000), // 10 second timeout
        });

        if (draftResponse.ok) {
          const draftData = await draftResponse.json();
          draft = { ...draft, ...draftData };
          await logToObservability(supabase, "INFO", "Agent SDK draft generated", {
            conversation_id: conversation.id,
            confidence_score: draft.confidence_score,
          });
        } else {
          await logToObservability(supabase, "WARN", "Agent SDK draft generation failed", {
            conversation_id: conversation.id,
            status: draftResponse.status,
          });
        }
      } catch (error) {
        await logToObservability(supabase, "WARN", "Agent SDK service unavailable", {
          conversation_id: conversation.id,
          error: error.message,
        });
      }

      // Step 3: Format draft note with rich context
      const draftNote = formatDraftNote(draft, message.content);

      // Step 4: Create private note in Chatwoot
      let chatwootMessageId = null;
      if (chatwootToken) {
        try {
          const privateNoteResponse = await fetch(
            `${chatwootBaseUrl}/api/v1/accounts/${payload.account.id}/conversations/${conversation.id}/messages`,
            {
              method: "POST",
              headers: {
                "api_access_token": chatwootToken,
                "Content-Type": "application/json",
              },
              body: JSON.stringify({
                content: draftNote,
                message_type: 0,
                private: true,
              }),
            }
          );

          if (privateNoteResponse.ok) {
            const noteData = await privateNoteResponse.json();
            chatwootMessageId = noteData.id;
            await logToObservability(supabase, "INFO", "Private note created in Chatwoot", {
              conversation_id: conversation.id,
              message_id: chatwootMessageId,
            });
          } else {
            await logToObservability(supabase, "WARN", "Failed to create private note", {
              conversation_id: conversation.id,
              status: privateNoteResponse.status,
            });
          }
        } catch (error) {
          await logToObservability(supabase, "WARN", "Chatwoot API error", {
            conversation_id: conversation.id,
            error: error.message,
          });
        }
      }

      // Step 5: Determine priority based on confidence and sentiment
      let priority = "normal";
      if (draft.confidence_score < 60 || draft.sentiment?.urgency === "high") {
        priority = "high";
      }
      if (draft.confidence_score < 40 || draft.sentiment?.urgency === "urgent") {
        priority = "urgent";
      }

      // Step 6: Insert into approval queue
      const { data: queueItem, error: insertError } = await supabase
        .from("agent_approvals")
        .insert({
          conversation_id: `chatwoot_${conversation.id}`,
          chatwoot_conversation_id: conversation.id,
          chatwoot_message_id: chatwootMessageId,
          inbox_id: conversation.inbox_id,
          customer_name: conversation.contact?.name,
          customer_email: conversation.contact?.email,
          customer_message: message.content,
          draft_response: draft.draft_response,
          confidence_score: draft.confidence_score,
          knowledge_sources: draft.sources,
          suggested_tags: draft.suggested_tags,
          sentiment_analysis: draft.sentiment,
          recommended_action: draft.recommended_action,
          priority: priority,
          status: "pending",
          serialized: {
            payload: payload,
            draft: draft,
            knowledge: knowledgeResults,
          },
        })
        .select()
        .single();

      if (insertError) {
        throw new Error(`Failed to insert queue item: ${insertError.message}`);
      }

      // Step 7: Create notification for operators
      await supabase.from("agent_sdk_notifications").insert({
        type: priority === "urgent" ? "urgent_review_needed" : "new_draft",
        queue_item_id: queueItem.id,
        conversation_id: conversation.id,
        priority: priority,
      });

      await logToObservability(
        supabase,
        "INFO",
        "Agent SDK approval queue item created",
        {
          conversation_id: conversation.id,
          queue_item_id: queueItem.id,
          confidence_score: draft.confidence_score,
          priority: priority,
          processing_time_ms: Date.now() - startTime,
        }
      );

      return new Response(
        JSON.stringify({
          ok: true,
          message: "Draft generated and queued for approval",
          conversation_id: conversation.id,
          queue_item_id: queueItem.id,
          confidence_score: draft.confidence_score,
          priority: priority,
        }),
        {
          headers: { ...corsHeaders, "Content-Type": "application/json" },
        }
      );
    } catch (integrationError) {
      // If integration fails, log and queue for manual handling
      await logToObservability(
        supabase,
        "ERROR",
        "Agent SDK integration error",
        {
          conversation_id: conversation.id,
          error: integrationError.message,
          stack: integrationError.stack,
        }
      );

      // Still insert a basic queue item for manual processing
      await supabase.from("agent_approvals").insert({
        conversation_id: `chatwoot_${conversation.id}`,
        chatwoot_conversation_id: conversation.id,
        customer_name: conversation.contact?.name,
        customer_email: conversation.contact?.email,
        customer_message: message.content,
        draft_response: "Error generating draft. Please respond manually.",
        confidence_score: 0,
        priority: "high",
        status: "pending",
        serialized: {
          payload: payload,
          error: integrationError.message,
        },
      });

      return new Response(
        JSON.stringify({
          ok: true,
          message: "Queued for manual processing (integration error)",
          conversation_id: conversation.id,
          error: integrationError.message,
        }),
        {
          headers: { ...corsHeaders, "Content-Type": "application/json" },
        }
      );
    }
  } catch (error) {
    console.error("Chatwoot webhook error:", error);

    return new Response(
      JSON.stringify({
        error: "Internal server error",
        details: error.message,
      }),
      {
        status: 500,
        headers: { ...corsHeaders, "Content-Type": "application/json" },
      }
    );
  }
});

