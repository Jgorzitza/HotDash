# Data Agent Feedback — 2025-10-15

## Startup Checklist Completed

### 0) Align to the Star ✅
- Reviewed `docs/NORTH_STAR.md` — Vision: Trustworthy operator-first control center with HITL approvals
- Reviewed `docs/OPERATING_MODEL.md` — Workflow: Signals → Suggestions → Approvals → Actions → Audit → Learn
- Reviewed `docs/RULES.md` — Documentation policy, security, task workflow
- **Alignment check:** Direction aligns with North Star. Approvals and audit schemas are foundational to HITL workflow.

### 1) Direction & Issue ✅
- Read `docs/directions/data.md`
- **Today's objective:** Design approvals schema (approvals, grades, edits tables) + audit log schema
- **Deadline:** 2025-10-17 (2 days)
- **Allowed paths:** `supabase/migrations/*, docs/specs/approvals_schema.md, docs/specs/audit_schema.md`
- **DoD:** Tables with RLS policies, migrations tested up/down, documented in specs
- **Blocker identified:** Need Supabase staging project access (will request from manager)

### 2) Tools & Env
- **Supabase MCP:** Need to verify connection (pending staging access)
- **Context7 MCP:** Will use to find existing schema patterns
- **GitHub MCP:** Will use for PR creation

### 3) Sandbox & Branch
- Current branch: `agent/engineer/dashboard-foundation` (wrong agent)
- **Action needed:** Create branch `agent/data/schema-foundation`

### 4) Feedback Discipline ✅
- This file created: `feedback/data/2025-10-15.md`

## Plan for Today

### Phase 1: Information Gathering (30 min)
1. ✅ Review `docs/specs/approvals_drawer_spec.md` for data requirements
2. Check existing Supabase migrations structure
3. Use Context7 to find existing schema patterns
4. Review RLS policy examples in codebase

### Phase 2: Schema Design (60 min)
1. Design approvals schema based on spec requirements:
   - `approvals` table (core approval workflow)
   - `approval_items` table (line items/diffs)
   - `ai_reviews` table (HITL grading: tone/accuracy/policy)
   - `approval_edits` table (capture human edits for learning)
2. Design audit log schema:
   - `audit_logs` table (immutable, append-only)
   - Constraints for immutability
   - Indexes for performance

### Phase 3: RLS Policies (45 min)
1. Design RLS policies for each table
2. Ensure least-privilege access
3. Document policy rationale

### Phase 4: Migration Creation (45 min)
1. Write migration with up/down
2. Include indexes for common query patterns
3. Add seed data for testing

### Phase 5: Documentation (30 min)
1. Document schema in `docs/specs/approvals_schema.md`
2. Document schema in `docs/specs/audit_schema.md`
3. Include ER diagrams (text-based)
4. Document RLS policies and rationale

### Phase 6: Testing (pending staging access)
1. Request Supabase staging access from manager
2. Test migration up/down
3. Test RLS policies with different roles
4. Verify query performance

## Blockers

### BLOCKER 1: Supabase Staging Access
- **Status:** Need staging project access to test migrations
- **Action:** Request from manager
- **Impact:** Cannot test migrations until resolved
- **Workaround:** Can design schema and write migrations, but cannot test

## Next Steps

1. Create branch `agent/data/schema-foundation`
2. Check existing Supabase migrations structure
3. Use Context7 to find schema patterns
4. Design approvals and audit schemas
5. Request Supabase staging access from manager

## Questions for Manager

1. Do we have a Supabase staging project set up? If so, what are the connection details?
2. Should the `approval_edits` table be separate from `ai_reviews`, or combined?
3. What user roles should RLS policies support? (e.g., admin, reviewer, agent, read-only)
4. Should audit logs have a retention policy enforced at the database level, or handled by a cron job?

## Progress

- [x] Startup checklist completed
- [x] Direction file reviewed
- [x] Approvals drawer spec reviewed
- [x] Branch created: `agent/data/schema-foundation`
- [x] Existing migrations reviewed
- [ ] Schema designed
- [ ] RLS policies designed
- [ ] Migration written
- [ ] Documentation written
- [ ] Staging access obtained
- [ ] Migration tested
- [ ] PR created

## Findings from Existing Migrations

### Existing Approvals Table
- Found `agent_approvals` table (20251011150400) for Agent SDK
- Schema is different from spec requirements in `approvals_drawer_spec.md`
- Current: conversation-focused (Agent SDK serialization)
- Spec needs: kind-based (cx_reply, inventory, growth, misc) with evidence/impact/rollback

### RLS Patterns Identified
1. **Service role full access** - Standard pattern for all tables
2. **Immutable audit records** - Prevent UPDATE/DELETE for authenticated users
3. **Role-based access** - Use JWT claims for role checking (operator_readonly, qa_team, etc.)
4. **Scope isolation** - Use JWT claims or session variables for multi-tenant isolation
5. **Trigger for updated_at** - Standard pattern using `set_updated_at()` function

### Migration Structure
- All migrations have `.sql` and `.rollback.sql` files
- Rollback files drop in reverse order: triggers → policies → indexes → table
- Comments on tables and columns for documentation
- Explicit GRANT statements for permissions

## Schema Design Decisions

### Decision 1: New Approvals Schema vs Extending Existing
**Decision:** Create NEW approvals schema per spec, keep existing `agent_approvals` for Agent SDK
**Rationale:**
- Spec requirements differ significantly from existing table
- Existing table is Agent SDK-specific (conversation serialization)
- New schema is workflow-specific (evidence, impact, rollback, actions)
- Both can coexist for different purposes

### Decision 2: Separate Tables for Grades and Edits
**Decision:** Create separate `approval_grades` and `approval_edits` tables
**Rationale:**
- Grades are 1:1 with approvals (one grade per approval)
- Edits can be multiple per approval (iterative human corrections)
- Separation allows better querying and analytics
- Follows normalization principles

### Decision 3: Audit Log Immutability
**Decision:** Use RLS policies + trigger to enforce immutability
**Rationale:**
- RLS prevents UPDATE/DELETE for authenticated users
- Service role can still cleanup for retention
- Trigger can prevent updates even for service role if needed
- Follows existing pattern in codebase

